/* tslint:disable */
/* eslint-disable */
/**
 * Shortcut API
 * Shortcut API
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Category,
  CreateCategory,
  CreateCommentComment,
  CreateEntityTemplate,
  CreateEpic,
  CreateEpicComment,
  CreateGroup,
  CreateIteration,
  CreateLabelParams,
  CreateLinkedFile,
  CreateMilestone,
  CreateOrDeleteStoryReaction,
  CreateProject,
  CreateStories,
  CreateStoryComment,
  CreateStoryLink,
  CreateStoryParams,
  CreateTask,
  CustomField,
  DataConflictError,
  DeleteStories,
  EntityTemplate,
  Epic,
  EpicSearchResults,
  EpicSlim,
  EpicWorkflow,
  GetEpicStories,
  GetExternalLinkStoriesParams,
  GetIterationStories,
  GetLabelStories,
  GetMember,
  GetProjectStories,
  Group,
  History,
  Iteration,
  IterationSearchResults,
  IterationSlim,
  Label,
  LinkedFile,
  ListEpics,
  ListGroupStories,
  ListLabels,
  ListMembers,
  MaxSearchResultsExceededError,
  Member,
  MemberInfo,
  Milestone,
  MilestoneSearchResults,
  Project,
  Repository,
  Search,
  SearchResults,
  SearchStories,
  Story,
  StoryComment,
  StoryLink,
  StoryReaction,
  StorySearchResults,
  StorySlim,
  Task,
  ThreadedComment,
  UnusableEntitlementError,
  UpdateCategory,
  UpdateComment,
  UpdateCustomField,
  UpdateEntityTemplate,
  UpdateEpic,
  UpdateFile,
  UpdateGroup,
  UpdateIteration,
  UpdateLabel,
  UpdateLinkedFile,
  UpdateMilestone,
  UpdateProject,
  UpdateStories,
  UpdateStory,
  UpdateStoryComment,
  UpdateStoryLink,
  UpdateTask,
  UploadedFile,
  Workflow,
} from '../models';
import {
    CategoryFromJSON,
    CategoryToJSON,
    CreateCategoryFromJSON,
    CreateCategoryToJSON,
    CreateCommentCommentFromJSON,
    CreateCommentCommentToJSON,
    CreateEntityTemplateFromJSON,
    CreateEntityTemplateToJSON,
    CreateEpicFromJSON,
    CreateEpicToJSON,
    CreateEpicCommentFromJSON,
    CreateEpicCommentToJSON,
    CreateGroupFromJSON,
    CreateGroupToJSON,
    CreateIterationFromJSON,
    CreateIterationToJSON,
    CreateLabelParamsFromJSON,
    CreateLabelParamsToJSON,
    CreateLinkedFileFromJSON,
    CreateLinkedFileToJSON,
    CreateMilestoneFromJSON,
    CreateMilestoneToJSON,
    CreateOrDeleteStoryReactionFromJSON,
    CreateOrDeleteStoryReactionToJSON,
    CreateProjectFromJSON,
    CreateProjectToJSON,
    CreateStoriesFromJSON,
    CreateStoriesToJSON,
    CreateStoryCommentFromJSON,
    CreateStoryCommentToJSON,
    CreateStoryLinkFromJSON,
    CreateStoryLinkToJSON,
    CreateStoryParamsFromJSON,
    CreateStoryParamsToJSON,
    CreateTaskFromJSON,
    CreateTaskToJSON,
    CustomFieldFromJSON,
    CustomFieldToJSON,
    DataConflictErrorFromJSON,
    DataConflictErrorToJSON,
    DeleteStoriesFromJSON,
    DeleteStoriesToJSON,
    EntityTemplateFromJSON,
    EntityTemplateToJSON,
    EpicFromJSON,
    EpicToJSON,
    EpicSearchResultsFromJSON,
    EpicSearchResultsToJSON,
    EpicSlimFromJSON,
    EpicSlimToJSON,
    EpicWorkflowFromJSON,
    EpicWorkflowToJSON,
    GetEpicStoriesFromJSON,
    GetEpicStoriesToJSON,
    GetExternalLinkStoriesParamsFromJSON,
    GetExternalLinkStoriesParamsToJSON,
    GetIterationStoriesFromJSON,
    GetIterationStoriesToJSON,
    GetLabelStoriesFromJSON,
    GetLabelStoriesToJSON,
    GetMemberFromJSON,
    GetMemberToJSON,
    GetProjectStoriesFromJSON,
    GetProjectStoriesToJSON,
    GroupFromJSON,
    GroupToJSON,
    HistoryFromJSON,
    HistoryToJSON,
    IterationFromJSON,
    IterationToJSON,
    IterationSearchResultsFromJSON,
    IterationSearchResultsToJSON,
    IterationSlimFromJSON,
    IterationSlimToJSON,
    LabelFromJSON,
    LabelToJSON,
    LinkedFileFromJSON,
    LinkedFileToJSON,
    ListEpicsFromJSON,
    ListEpicsToJSON,
    ListGroupStoriesFromJSON,
    ListGroupStoriesToJSON,
    ListLabelsFromJSON,
    ListLabelsToJSON,
    ListMembersFromJSON,
    ListMembersToJSON,
    MaxSearchResultsExceededErrorFromJSON,
    MaxSearchResultsExceededErrorToJSON,
    MemberFromJSON,
    MemberToJSON,
    MemberInfoFromJSON,
    MemberInfoToJSON,
    MilestoneFromJSON,
    MilestoneToJSON,
    MilestoneSearchResultsFromJSON,
    MilestoneSearchResultsToJSON,
    ProjectFromJSON,
    ProjectToJSON,
    RepositoryFromJSON,
    RepositoryToJSON,
    SearchFromJSON,
    SearchToJSON,
    SearchResultsFromJSON,
    SearchResultsToJSON,
    SearchStoriesFromJSON,
    SearchStoriesToJSON,
    StoryFromJSON,
    StoryToJSON,
    StoryCommentFromJSON,
    StoryCommentToJSON,
    StoryLinkFromJSON,
    StoryLinkToJSON,
    StoryReactionFromJSON,
    StoryReactionToJSON,
    StorySearchResultsFromJSON,
    StorySearchResultsToJSON,
    StorySlimFromJSON,
    StorySlimToJSON,
    TaskFromJSON,
    TaskToJSON,
    ThreadedCommentFromJSON,
    ThreadedCommentToJSON,
    UnusableEntitlementErrorFromJSON,
    UnusableEntitlementErrorToJSON,
    UpdateCategoryFromJSON,
    UpdateCategoryToJSON,
    UpdateCommentFromJSON,
    UpdateCommentToJSON,
    UpdateCustomFieldFromJSON,
    UpdateCustomFieldToJSON,
    UpdateEntityTemplateFromJSON,
    UpdateEntityTemplateToJSON,
    UpdateEpicFromJSON,
    UpdateEpicToJSON,
    UpdateFileFromJSON,
    UpdateFileToJSON,
    UpdateGroupFromJSON,
    UpdateGroupToJSON,
    UpdateIterationFromJSON,
    UpdateIterationToJSON,
    UpdateLabelFromJSON,
    UpdateLabelToJSON,
    UpdateLinkedFileFromJSON,
    UpdateLinkedFileToJSON,
    UpdateMilestoneFromJSON,
    UpdateMilestoneToJSON,
    UpdateProjectFromJSON,
    UpdateProjectToJSON,
    UpdateStoriesFromJSON,
    UpdateStoriesToJSON,
    UpdateStoryFromJSON,
    UpdateStoryToJSON,
    UpdateStoryCommentFromJSON,
    UpdateStoryCommentToJSON,
    UpdateStoryLinkFromJSON,
    UpdateStoryLinkToJSON,
    UpdateTaskFromJSON,
    UpdateTaskToJSON,
    UploadedFileFromJSON,
    UploadedFileToJSON,
    WorkflowFromJSON,
    WorkflowToJSON,
} from '../models';

export interface CreateCategoryRequest {
    createCategory: CreateCategory;
}

export interface CreateEntityTemplateRequest {
    createEntityTemplate: CreateEntityTemplate;
}

export interface CreateEpicRequest {
    createEpic: CreateEpic;
}

export interface CreateEpicCommentRequest {
    epicPublicId: number;
    createEpicComment: CreateEpicComment;
}

export interface CreateEpicCommentCommentRequest {
    epicPublicId: number;
    commentPublicId: number;
    createCommentComment: CreateCommentComment;
}

export interface CreateGroupRequest {
    createGroup: CreateGroup;
}

export interface CreateIterationRequest {
    createIteration: CreateIteration;
}

export interface CreateLabelRequest {
    createLabelParams: CreateLabelParams;
}

export interface CreateLinkedFileRequest {
    createLinkedFile: CreateLinkedFile;
}

export interface CreateMilestoneRequest {
    createMilestone: CreateMilestone;
}

export interface CreateMultipleStoriesRequest {
    createStories: CreateStories;
}

export interface CreateProjectRequest {
    createProject: CreateProject;
}

export interface CreateStoryRequest {
    createStoryParams: CreateStoryParams;
}

export interface CreateStoryCommentRequest {
    storyPublicId: number;
    createStoryComment: CreateStoryComment;
}

export interface CreateStoryLinkRequest {
    createStoryLink: CreateStoryLink;
}

export interface CreateStoryReactionRequest {
    storyPublicId: number;
    commentPublicId: number;
    createOrDeleteStoryReaction: CreateOrDeleteStoryReaction;
}

export interface CreateTaskRequest {
    storyPublicId: number;
    createTask: CreateTask;
}

export interface DeleteCategoryRequest {
    categoryPublicId: number;
}

export interface DeleteCustomFieldRequest {
    customFieldPublicId: string;
}

export interface DeleteEntityTemplateRequest {
    entityTemplatePublicId: string;
}

export interface DeleteEpicRequest {
    epicPublicId: number;
}

export interface DeleteEpicCommentRequest {
    epicPublicId: number;
    commentPublicId: number;
}

export interface DeleteFileRequest {
    filePublicId: number;
}

export interface DeleteIterationRequest {
    iterationPublicId: number;
}

export interface DeleteLabelRequest {
    labelPublicId: number;
}

export interface DeleteLinkedFileRequest {
    linkedFilePublicId: number;
}

export interface DeleteMilestoneRequest {
    milestonePublicId: number;
}

export interface DeleteMultipleStoriesRequest {
    deleteStories: DeleteStories;
}

export interface DeleteProjectRequest {
    projectPublicId: number;
}

export interface DeleteStoryRequest {
    storyPublicId: number;
}

export interface DeleteStoryCommentRequest {
    storyPublicId: number;
    commentPublicId: number;
}

export interface DeleteStoryLinkRequest {
    storyLinkPublicId: number;
}

export interface DeleteStoryReactionRequest {
    storyPublicId: number;
    commentPublicId: number;
    createOrDeleteStoryReaction: CreateOrDeleteStoryReaction;
}

export interface DeleteTaskRequest {
    storyPublicId: number;
    taskPublicId: number;
}

export interface GetCategoryRequest {
    categoryPublicId: number;
}

export interface GetCustomFieldRequest {
    customFieldPublicId: string;
}

export interface GetEntityTemplateRequest {
    entityTemplatePublicId: string;
}

export interface GetEpicRequest {
    epicPublicId: number;
}

export interface GetEpicCommentRequest {
    epicPublicId: number;
    commentPublicId: number;
}

export interface GetExternalLinkStoriesRequest {
    getExternalLinkStoriesParams: GetExternalLinkStoriesParams;
}

export interface GetFileRequest {
    filePublicId: number;
}

export interface GetGroupRequest {
    groupPublicId: string;
}

export interface GetIterationRequest {
    iterationPublicId: number;
}

export interface GetLabelRequest {
    labelPublicId: number;
}

export interface GetLinkedFileRequest {
    linkedFilePublicId: number;
}

export interface GetMemberRequest {
    memberPublicId: string;
    getMember: GetMember;
}

export interface GetMilestoneRequest {
    milestonePublicId: number;
}

export interface GetProjectRequest {
    projectPublicId: number;
}

export interface GetRepositoryRequest {
    repoPublicId: number;
}

export interface GetStoryRequest {
    storyPublicId: number;
}

export interface GetStoryCommentRequest {
    storyPublicId: number;
    commentPublicId: number;
}

export interface GetStoryLinkRequest {
    storyLinkPublicId: number;
}

export interface GetTaskRequest {
    storyPublicId: number;
    taskPublicId: number;
}

export interface GetWorkflowRequest {
    workflowPublicId: number;
}

export interface ListCategoryMilestonesRequest {
    categoryPublicId: number;
}

export interface ListEpicCommentsRequest {
    epicPublicId: number;
}

export interface ListEpicStoriesRequest {
    epicPublicId: number;
    getEpicStories: GetEpicStories;
}

export interface ListEpicsRequest {
    listEpics: ListEpics;
}

export interface ListGroupStoriesRequest {
    groupPublicId: string;
    listGroupStories: ListGroupStories;
}

export interface ListIterationStoriesRequest {
    iterationPublicId: number;
    getIterationStories: GetIterationStories;
}

export interface ListLabelEpicsRequest {
    labelPublicId: number;
}

export interface ListLabelStoriesRequest {
    labelPublicId: number;
    getLabelStories: GetLabelStories;
}

export interface ListLabelsRequest {
    listLabels: ListLabels;
}

export interface ListMembersRequest {
    listMembers: ListMembers;
}

export interface ListMilestoneEpicsRequest {
    milestonePublicId: number;
}

export interface ListStoriesRequest {
    projectPublicId: number;
    getProjectStories: GetProjectStories;
}

export interface ListStoryCommentRequest {
    storyPublicId: number;
}

export interface SearchRequest {
    search: Search;
}

export interface SearchEpicsRequest {
    search: Search;
}

export interface SearchIterationsRequest {
    search: Search;
}

export interface SearchMilestonesRequest {
    search: Search;
}

export interface SearchStoriesRequest {
    search: Search;
}

export interface SearchStoriesOldRequest {
    searchStories: SearchStories;
}

export interface StoryHistoryRequest {
    storyPublicId: number;
}

export interface UnlinkProductboardFromEpicRequest {
    epicPublicId: number;
}

export interface UpdateCategoryRequest {
    categoryPublicId: number;
    updateCategory: UpdateCategory;
}

export interface UpdateCustomFieldRequest {
    customFieldPublicId: string;
    updateCustomField: UpdateCustomField;
}

export interface UpdateEntityTemplateRequest {
    entityTemplatePublicId: string;
    updateEntityTemplate: UpdateEntityTemplate;
}

export interface UpdateEpicRequest {
    epicPublicId: number;
    updateEpic: UpdateEpic;
}

export interface UpdateEpicCommentRequest {
    epicPublicId: number;
    commentPublicId: number;
    updateComment: UpdateComment;
}

export interface UpdateFileRequest {
    filePublicId: number;
    updateFile: UpdateFile;
}

export interface UpdateGroupRequest {
    groupPublicId: string;
    updateGroup: UpdateGroup;
}

export interface UpdateIterationRequest {
    iterationPublicId: number;
    updateIteration: UpdateIteration;
}

export interface UpdateLabelRequest {
    labelPublicId: number;
    updateLabel: UpdateLabel;
}

export interface UpdateLinkedFileRequest {
    linkedFilePublicId: number;
    updateLinkedFile: UpdateLinkedFile;
}

export interface UpdateMilestoneRequest {
    milestonePublicId: number;
    updateMilestone: UpdateMilestone;
}

export interface UpdateMultipleStoriesRequest {
    updateStories: UpdateStories;
}

export interface UpdateProjectRequest {
    projectPublicId: number;
    updateProject: UpdateProject;
}

export interface UpdateStoryRequest {
    storyPublicId: number;
    updateStory: UpdateStory;
}

export interface UpdateStoryCommentRequest {
    storyPublicId: number;
    commentPublicId: number;
    updateStoryComment: UpdateStoryComment;
}

export interface UpdateStoryLinkRequest {
    storyLinkPublicId: number;
    updateStoryLink: UpdateStoryLink;
}

export interface UpdateTaskRequest {
    storyPublicId: number;
    taskPublicId: number;
    updateTask: UpdateTask;
}

export interface UploadFilesRequest {
    file0: Blob;
    storyId?: number;
    file1?: Blob;
    file2?: Blob;
    file3?: Blob;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Create Category allows you to create a new Category in Shortcut.
     * Create Category
     */
    async createCategoryRaw(requestParameters: CreateCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Category>> {
        if (requestParameters.createCategory === null || requestParameters.createCategory === undefined) {
            throw new runtime.RequiredError('createCategory','Required parameter requestParameters.createCategory was null or undefined when calling createCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/categories`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCategoryToJSON(requestParameters.createCategory),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryFromJSON(jsonValue));
    }

    /**
     * Create Category allows you to create a new Category in Shortcut.
     * Create Category
     */
    async createCategory(requestParameters: CreateCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Category> {
        const response = await this.createCategoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new entity template for the Workspace.
     * Create Entity Template
     */
    async createEntityTemplateRaw(requestParameters: CreateEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityTemplate>> {
        if (requestParameters.createEntityTemplate === null || requestParameters.createEntityTemplate === undefined) {
            throw new runtime.RequiredError('createEntityTemplate','Required parameter requestParameters.createEntityTemplate was null or undefined when calling createEntityTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateEntityTemplateToJSON(requestParameters.createEntityTemplate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityTemplateFromJSON(jsonValue));
    }

    /**
     * Create a new entity template for the Workspace.
     * Create Entity Template
     */
    async createEntityTemplate(requestParameters: CreateEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityTemplate> {
        const response = await this.createEntityTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Epic allows you to create a new Epic in Shortcut.
     * Create Epic
     */
    async createEpicRaw(requestParameters: CreateEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Epic>> {
        if (requestParameters.createEpic === null || requestParameters.createEpic === undefined) {
            throw new runtime.RequiredError('createEpic','Required parameter requestParameters.createEpic was null or undefined when calling createEpic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateEpicToJSON(requestParameters.createEpic),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EpicFromJSON(jsonValue));
    }

    /**
     * Create Epic allows you to create a new Epic in Shortcut.
     * Create Epic
     */
    async createEpic(requestParameters: CreateEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Epic> {
        const response = await this.createEpicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint allows you to create a threaded Comment on an Epic.
     * Create Epic Comment
     */
    async createEpicCommentRaw(requestParameters: CreateEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadedComment>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling createEpicComment.');
        }

        if (requestParameters.createEpicComment === null || requestParameters.createEpicComment === undefined) {
            throw new runtime.RequiredError('createEpicComment','Required parameter requestParameters.createEpicComment was null or undefined when calling createEpicComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/comments`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateEpicCommentToJSON(requestParameters.createEpicComment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadedCommentFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to create a threaded Comment on an Epic.
     * Create Epic Comment
     */
    async createEpicComment(requestParameters: CreateEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadedComment> {
        const response = await this.createEpicCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint allows you to create a nested Comment reply to an existing Epic Comment.
     * Create Epic Comment Comment
     */
    async createEpicCommentCommentRaw(requestParameters: CreateEpicCommentCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadedComment>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling createEpicCommentComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling createEpicCommentComment.');
        }

        if (requestParameters.createCommentComment === null || requestParameters.createCommentComment === undefined) {
            throw new runtime.RequiredError('createCommentComment','Required parameter requestParameters.createCommentComment was null or undefined when calling createEpicCommentComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/comments/{comment-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCommentCommentToJSON(requestParameters.createCommentComment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadedCommentFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to create a nested Comment reply to an existing Epic Comment.
     * Create Epic Comment Comment
     */
    async createEpicCommentComment(requestParameters: CreateEpicCommentCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadedComment> {
        const response = await this.createEpicCommentCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Group
     */
    async createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>> {
        if (requestParameters.createGroup === null || requestParameters.createGroup === undefined) {
            throw new runtime.RequiredError('createGroup','Required parameter requestParameters.createGroup was null or undefined when calling createGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateGroupToJSON(requestParameters.createGroup),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     * Create Group
     */
    async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group> {
        const response = await this.createGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Iteration
     */
    async createIterationRaw(requestParameters: CreateIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Iteration>> {
        if (requestParameters.createIteration === null || requestParameters.createIteration === undefined) {
            throw new runtime.RequiredError('createIteration','Required parameter requestParameters.createIteration was null or undefined when calling createIteration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateIterationToJSON(requestParameters.createIteration),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IterationFromJSON(jsonValue));
    }

    /**
     * Create Iteration
     */
    async createIteration(requestParameters: CreateIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Iteration> {
        const response = await this.createIterationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Label allows you to create a new Label in Shortcut.
     * Create Label
     */
    async createLabelRaw(requestParameters: CreateLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.createLabelParams === null || requestParameters.createLabelParams === undefined) {
            throw new runtime.RequiredError('createLabelParams','Required parameter requestParameters.createLabelParams was null or undefined when calling createLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateLabelParamsToJSON(requestParameters.createLabelParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * Create Label allows you to create a new Label in Shortcut.
     * Create Label
     */
    async createLabel(requestParameters: CreateLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Label> {
        const response = await this.createLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Linked File allows you to create a new Linked File in Shortcut.
     * Create Linked File
     */
    async createLinkedFileRaw(requestParameters: CreateLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LinkedFile>> {
        if (requestParameters.createLinkedFile === null || requestParameters.createLinkedFile === undefined) {
            throw new runtime.RequiredError('createLinkedFile','Required parameter requestParameters.createLinkedFile was null or undefined when calling createLinkedFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/linked-files`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateLinkedFileToJSON(requestParameters.createLinkedFile),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LinkedFileFromJSON(jsonValue));
    }

    /**
     * Create Linked File allows you to create a new Linked File in Shortcut.
     * Create Linked File
     */
    async createLinkedFile(requestParameters: CreateLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LinkedFile> {
        const response = await this.createLinkedFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Milestone allows you to create a new Milestone in Shortcut.
     * Create Milestone
     */
    async createMilestoneRaw(requestParameters: CreateMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Milestone>> {
        if (requestParameters.createMilestone === null || requestParameters.createMilestone === undefined) {
            throw new runtime.RequiredError('createMilestone','Required parameter requestParameters.createMilestone was null or undefined when calling createMilestone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/milestones`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMilestoneToJSON(requestParameters.createMilestone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MilestoneFromJSON(jsonValue));
    }

    /**
     * Create Milestone allows you to create a new Milestone in Shortcut.
     * Create Milestone
     */
    async createMilestone(requestParameters: CreateMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Milestone> {
        const response = await this.createMilestoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Multiple Stories allows you to create multiple stories in a single request using the same syntax as [Create Story](https://developer.shortcut.com/api/rest/v3#create-story).
     * Create Multiple Stories
     */
    async createMultipleStoriesRaw(requestParameters: CreateMultipleStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.createStories === null || requestParameters.createStories === undefined) {
            throw new runtime.RequiredError('createStories','Required parameter requestParameters.createStories was null or undefined when calling createMultipleStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateStoriesToJSON(requestParameters.createStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * Create Multiple Stories allows you to create multiple stories in a single request using the same syntax as [Create Story](https://developer.shortcut.com/api/rest/v3#create-story).
     * Create Multiple Stories
     */
    async createMultipleStories(requestParameters: CreateMultipleStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.createMultipleStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Project is used to create a new Shortcut Project.
     * Create Project
     */
    async createProjectRaw(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.createProject === null || requestParameters.createProject === undefined) {
            throw new runtime.RequiredError('createProject','Required parameter requestParameters.createProject was null or undefined when calling createProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateProjectToJSON(requestParameters.createProject),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Create Project is used to create a new Shortcut Project.
     * Create Project
     */
    async createProject(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.createProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Story is used to add a new story to your Shortcut.
     * Create Story
     */
    async createStoryRaw(requestParameters: CreateStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Story>> {
        if (requestParameters.createStoryParams === null || requestParameters.createStoryParams === undefined) {
            throw new runtime.RequiredError('createStoryParams','Required parameter requestParameters.createStoryParams was null or undefined when calling createStory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateStoryParamsToJSON(requestParameters.createStoryParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryFromJSON(jsonValue));
    }

    /**
     * Create Story is used to add a new story to your Shortcut.
     * Create Story
     */
    async createStory(requestParameters: CreateStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Story> {
        const response = await this.createStoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Comment allows you to create a Comment on any Story.
     * Create Story Comment
     */
    async createStoryCommentRaw(requestParameters: CreateStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoryComment>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling createStoryComment.');
        }

        if (requestParameters.createStoryComment === null || requestParameters.createStoryComment === undefined) {
            throw new runtime.RequiredError('createStoryComment','Required parameter requestParameters.createStoryComment was null or undefined when calling createStoryComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateStoryCommentToJSON(requestParameters.createStoryComment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryCommentFromJSON(jsonValue));
    }

    /**
     * Create Comment allows you to create a Comment on any Story.
     * Create Story Comment
     */
    async createStoryComment(requestParameters: CreateStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoryComment> {
        const response = await this.createStoryCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Story Links (called Story Relationships in the UI) allow you create semantic relationships between two stories. The parameters read like an active voice grammatical sentence:  subject -> verb -> object.  The subject story acts on the object Story; the object story is the direct object of the sentence.  The subject story \"blocks\", \"duplicates\", or \"relates to\" the object story.  Examples: - \"story 5 blocks story 6” -- story 6 is now \"blocked\" until story 5 is moved to a Done workflow state. - \"story 2 duplicates story 1” -- Story 2 represents the same body of work as Story 1 (and should probably be archived). - \"story 7 relates to story 3”
     * Create Story Link
     */
    async createStoryLinkRaw(requestParameters: CreateStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoryLink>> {
        if (requestParameters.createStoryLink === null || requestParameters.createStoryLink === undefined) {
            throw new runtime.RequiredError('createStoryLink','Required parameter requestParameters.createStoryLink was null or undefined when calling createStoryLink.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/story-links`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateStoryLinkToJSON(requestParameters.createStoryLink),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryLinkFromJSON(jsonValue));
    }

    /**
     * Story Links (called Story Relationships in the UI) allow you create semantic relationships between two stories. The parameters read like an active voice grammatical sentence:  subject -> verb -> object.  The subject story acts on the object Story; the object story is the direct object of the sentence.  The subject story \"blocks\", \"duplicates\", or \"relates to\" the object story.  Examples: - \"story 5 blocks story 6” -- story 6 is now \"blocked\" until story 5 is moved to a Done workflow state. - \"story 2 duplicates story 1” -- Story 2 represents the same body of work as Story 1 (and should probably be archived). - \"story 7 relates to story 3”
     * Create Story Link
     */
    async createStoryLink(requestParameters: CreateStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoryLink> {
        const response = await this.createStoryLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a reaction to a story comment.
     * Create Story Reaction
     */
    async createStoryReactionRaw(requestParameters: CreateStoryReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StoryReaction>>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling createStoryReaction.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling createStoryReaction.');
        }

        if (requestParameters.createOrDeleteStoryReaction === null || requestParameters.createOrDeleteStoryReaction === undefined) {
            throw new runtime.RequiredError('createOrDeleteStoryReaction','Required parameter requestParameters.createOrDeleteStoryReaction was null or undefined when calling createStoryReaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrDeleteStoryReactionToJSON(requestParameters.createOrDeleteStoryReaction),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StoryReactionFromJSON));
    }

    /**
     * Create a reaction to a story comment.
     * Create Story Reaction
     */
    async createStoryReaction(requestParameters: CreateStoryReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StoryReaction>> {
        const response = await this.createStoryReactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Task is used to create a new task in a Story.
     * Create Task
     */
    async createTaskRaw(requestParameters: CreateTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling createTask.');
        }

        if (requestParameters.createTask === null || requestParameters.createTask === undefined) {
            throw new runtime.RequiredError('createTask','Required parameter requestParameters.createTask was null or undefined when calling createTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/tasks`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTaskToJSON(requestParameters.createTask),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Create Task is used to create a new task in a Story.
     * Create Task
     */
    async createTask(requestParameters: CreateTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Task> {
        const response = await this.createTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Category can be used to delete any Category.
     * Delete Category
     */
    async deleteCategoryRaw(requestParameters: DeleteCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.categoryPublicId === null || requestParameters.categoryPublicId === undefined) {
            throw new runtime.RequiredError('categoryPublicId','Required parameter requestParameters.categoryPublicId was null or undefined when calling deleteCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/categories/{category-public-id}`.replace(`{${"category-public-id"}}`, encodeURIComponent(String(requestParameters.categoryPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Category can be used to delete any Category.
     * Delete Category
     */
    async deleteCategory(requestParameters: DeleteCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCategoryRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Custom Field
     */
    async deleteCustomFieldRaw(requestParameters: DeleteCustomFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.customFieldPublicId === null || requestParameters.customFieldPublicId === undefined) {
            throw new runtime.RequiredError('customFieldPublicId','Required parameter requestParameters.customFieldPublicId was null or undefined when calling deleteCustomField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/custom-fields/{custom-field-public-id}`.replace(`{${"custom-field-public-id"}}`, encodeURIComponent(String(requestParameters.customFieldPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Custom Field
     */
    async deleteCustomField(requestParameters: DeleteCustomFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCustomFieldRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Entity Template
     */
    async deleteEntityTemplateRaw(requestParameters: DeleteEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.entityTemplatePublicId === null || requestParameters.entityTemplatePublicId === undefined) {
            throw new runtime.RequiredError('entityTemplatePublicId','Required parameter requestParameters.entityTemplatePublicId was null or undefined when calling deleteEntityTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates/{entity-template-public-id}`.replace(`{${"entity-template-public-id"}}`, encodeURIComponent(String(requestParameters.entityTemplatePublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Entity Template
     */
    async deleteEntityTemplate(requestParameters: DeleteEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEntityTemplateRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Epic can be used to delete the Epic. The only required parameter is Epic ID.
     * Delete Epic
     */
    async deleteEpicRaw(requestParameters: DeleteEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling deleteEpic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Epic can be used to delete the Epic. The only required parameter is Epic ID.
     * Delete Epic
     */
    async deleteEpic(requestParameters: DeleteEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEpicRaw(requestParameters, initOverrides);
    }

    /**
     * This endpoint allows you to delete a Comment from an Epic.
     * Delete Epic Comment
     */
    async deleteEpicCommentRaw(requestParameters: DeleteEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling deleteEpicComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling deleteEpicComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/comments/{comment-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint allows you to delete a Comment from an Epic.
     * Delete Epic Comment
     */
    async deleteEpicComment(requestParameters: DeleteEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEpicCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete File deletes a previously uploaded file.
     * Delete File
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.filePublicId === null || requestParameters.filePublicId === undefined) {
            throw new runtime.RequiredError('filePublicId','Required parameter requestParameters.filePublicId was null or undefined when calling deleteFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/files/{file-public-id}`.replace(`{${"file-public-id"}}`, encodeURIComponent(String(requestParameters.filePublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete File deletes a previously uploaded file.
     * Delete File
     */
    async deleteFile(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFileRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Iteration
     */
    async deleteIterationRaw(requestParameters: DeleteIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.iterationPublicId === null || requestParameters.iterationPublicId === undefined) {
            throw new runtime.RequiredError('iterationPublicId','Required parameter requestParameters.iterationPublicId was null or undefined when calling deleteIteration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations/{iteration-public-id}`.replace(`{${"iteration-public-id"}}`, encodeURIComponent(String(requestParameters.iterationPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Iteration
     */
    async deleteIteration(requestParameters: DeleteIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteIterationRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Label can be used to delete any Label.
     * Delete Label
     */
    async deleteLabelRaw(requestParameters: DeleteLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.labelPublicId === null || requestParameters.labelPublicId === undefined) {
            throw new runtime.RequiredError('labelPublicId','Required parameter requestParameters.labelPublicId was null or undefined when calling deleteLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels/{label-public-id}`.replace(`{${"label-public-id"}}`, encodeURIComponent(String(requestParameters.labelPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Label can be used to delete any Label.
     * Delete Label
     */
    async deleteLabel(requestParameters: DeleteLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteLabelRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Linked File can be used to delete any previously attached Linked-File.
     * Delete Linked File
     */
    async deleteLinkedFileRaw(requestParameters: DeleteLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.linkedFilePublicId === null || requestParameters.linkedFilePublicId === undefined) {
            throw new runtime.RequiredError('linkedFilePublicId','Required parameter requestParameters.linkedFilePublicId was null or undefined when calling deleteLinkedFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/linked-files/{linked-file-public-id}`.replace(`{${"linked-file-public-id"}}`, encodeURIComponent(String(requestParameters.linkedFilePublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Linked File can be used to delete any previously attached Linked-File.
     * Delete Linked File
     */
    async deleteLinkedFile(requestParameters: DeleteLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteLinkedFileRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Milestone can be used to delete any Milestone.
     * Delete Milestone
     */
    async deleteMilestoneRaw(requestParameters: DeleteMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.milestonePublicId === null || requestParameters.milestonePublicId === undefined) {
            throw new runtime.RequiredError('milestonePublicId','Required parameter requestParameters.milestonePublicId was null or undefined when calling deleteMilestone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/milestones/{milestone-public-id}`.replace(`{${"milestone-public-id"}}`, encodeURIComponent(String(requestParameters.milestonePublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Milestone can be used to delete any Milestone.
     * Delete Milestone
     */
    async deleteMilestone(requestParameters: DeleteMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMilestoneRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Multiple Stories allows you to delete multiple archived stories at once.
     * Delete Multiple Stories
     */
    async deleteMultipleStoriesRaw(requestParameters: DeleteMultipleStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.deleteStories === null || requestParameters.deleteStories === undefined) {
            throw new runtime.RequiredError('deleteStories','Required parameter requestParameters.deleteStories was null or undefined when calling deleteMultipleStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/bulk`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteStoriesToJSON(requestParameters.deleteStories),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Multiple Stories allows you to delete multiple archived stories at once.
     * Delete Multiple Stories
     */
    async deleteMultipleStories(requestParameters: DeleteMultipleStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMultipleStoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Project can be used to delete a Project. Projects can only be deleted if all associated Stories are moved or deleted. In the case that the Project cannot be deleted, you will receive a 422 response.
     * Delete Project
     */
    async deleteProjectRaw(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectPublicId === null || requestParameters.projectPublicId === undefined) {
            throw new runtime.RequiredError('projectPublicId','Required parameter requestParameters.projectPublicId was null or undefined when calling deleteProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/projects/{project-public-id}`.replace(`{${"project-public-id"}}`, encodeURIComponent(String(requestParameters.projectPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Project can be used to delete a Project. Projects can only be deleted if all associated Stories are moved or deleted. In the case that the Project cannot be deleted, you will receive a 422 response.
     * Delete Project
     */
    async deleteProject(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Story can be used to delete any Story.
     * Delete Story
     */
    async deleteStoryRaw(requestParameters: DeleteStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling deleteStory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Story can be used to delete any Story.
     * Delete Story
     */
    async deleteStory(requestParameters: DeleteStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteStoryRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a Comment from any story.
     * Delete Story Comment
     */
    async deleteStoryCommentRaw(requestParameters: DeleteStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling deleteStoryComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling deleteStoryComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments/{comment-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Comment from any story.
     * Delete Story Comment
     */
    async deleteStoryComment(requestParameters: DeleteStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteStoryCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Removes the relationship between the stories for the given Story Link.
     * Delete Story Link
     */
    async deleteStoryLinkRaw(requestParameters: DeleteStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.storyLinkPublicId === null || requestParameters.storyLinkPublicId === undefined) {
            throw new runtime.RequiredError('storyLinkPublicId','Required parameter requestParameters.storyLinkPublicId was null or undefined when calling deleteStoryLink.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/story-links/{story-link-public-id}`.replace(`{${"story-link-public-id"}}`, encodeURIComponent(String(requestParameters.storyLinkPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the relationship between the stories for the given Story Link.
     * Delete Story Link
     */
    async deleteStoryLink(requestParameters: DeleteStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteStoryLinkRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a reaction from any story comment.
     * Delete Story Reaction
     */
    async deleteStoryReactionRaw(requestParameters: DeleteStoryReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling deleteStoryReaction.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling deleteStoryReaction.');
        }

        if (requestParameters.createOrDeleteStoryReaction === null || requestParameters.createOrDeleteStoryReaction === undefined) {
            throw new runtime.RequiredError('createOrDeleteStoryReaction','Required parameter requestParameters.createOrDeleteStoryReaction was null or undefined when calling deleteStoryReaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments/{comment-public-id}/reactions`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrDeleteStoryReactionToJSON(requestParameters.createOrDeleteStoryReaction),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a reaction from any story comment.
     * Delete Story Reaction
     */
    async deleteStoryReaction(requestParameters: DeleteStoryReactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteStoryReactionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Task can be used to delete any previously created Task on a Story.
     * Delete Task
     */
    async deleteTaskRaw(requestParameters: DeleteTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling deleteTask.');
        }

        if (requestParameters.taskPublicId === null || requestParameters.taskPublicId === undefined) {
            throw new runtime.RequiredError('taskPublicId','Required parameter requestParameters.taskPublicId was null or undefined when calling deleteTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/tasks/{task-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"task-public-id"}}`, encodeURIComponent(String(requestParameters.taskPublicId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Task can be used to delete any previously created Task on a Story.
     * Delete Task
     */
    async deleteTask(requestParameters: DeleteTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTaskRaw(requestParameters, initOverrides);
    }

    /**
     * Disables Groups for the current workspace2
     * Disable Groups
     */
    async disableGroupsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups/disable`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disables Groups for the current workspace2
     * Disable Groups
     */
    async disableGroups(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.disableGroupsRaw(initOverrides);
    }

    /**
     * Disables Iterations for the current workspace
     * Disable Iterations
     */
    async disableIterationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations/disable`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disables Iterations for the current workspace
     * Disable Iterations
     */
    async disableIterations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.disableIterationsRaw(initOverrides);
    }

    /**
     * Disables the Story Template feature for the Workspace.
     * Disable Story Templates
     */
    async disableStoryTemplatesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates/disable`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disables the Story Template feature for the Workspace.
     * Disable Story Templates
     */
    async disableStoryTemplates(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.disableStoryTemplatesRaw(initOverrides);
    }

    /**
     * Enables Groups for the current workspace2
     * Enable Groups
     */
    async enableGroupsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups/enable`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables Groups for the current workspace2
     * Enable Groups
     */
    async enableGroups(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableGroupsRaw(initOverrides);
    }

    /**
     * Enables Iterations for the current workspace
     * Enable Iterations
     */
    async enableIterationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations/enable`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables Iterations for the current workspace
     * Enable Iterations
     */
    async enableIterations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableIterationsRaw(initOverrides);
    }

    /**
     * Enables the Story Template feature for the Workspace.
     * Enable Story Templates
     */
    async enableStoryTemplatesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates/enable`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables the Story Template feature for the Workspace.
     * Enable Story Templates
     */
    async enableStoryTemplates(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableStoryTemplatesRaw(initOverrides);
    }

    /**
     * Get Category returns information about the selected Category.
     * Get Category
     */
    async getCategoryRaw(requestParameters: GetCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Category>> {
        if (requestParameters.categoryPublicId === null || requestParameters.categoryPublicId === undefined) {
            throw new runtime.RequiredError('categoryPublicId','Required parameter requestParameters.categoryPublicId was null or undefined when calling getCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/categories/{category-public-id}`.replace(`{${"category-public-id"}}`, encodeURIComponent(String(requestParameters.categoryPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryFromJSON(jsonValue));
    }

    /**
     * Get Category returns information about the selected Category.
     * Get Category
     */
    async getCategory(requestParameters: GetCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Category> {
        const response = await this.getCategoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information about the authenticated member.
     * Get Current Member Info
     */
    async getCurrentMemberInfoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MemberInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/member`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MemberInfoFromJSON(jsonValue));
    }

    /**
     * Returns information about the authenticated member.
     * Get Current Member Info
     */
    async getCurrentMemberInfo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MemberInfo> {
        const response = await this.getCurrentMemberInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get Custom Field
     */
    async getCustomFieldRaw(requestParameters: GetCustomFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomField>> {
        if (requestParameters.customFieldPublicId === null || requestParameters.customFieldPublicId === undefined) {
            throw new runtime.RequiredError('customFieldPublicId','Required parameter requestParameters.customFieldPublicId was null or undefined when calling getCustomField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/custom-fields/{custom-field-public-id}`.replace(`{${"custom-field-public-id"}}`, encodeURIComponent(String(requestParameters.customFieldPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFieldFromJSON(jsonValue));
    }

    /**
     * Get Custom Field
     */
    async getCustomField(requestParameters: GetCustomFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomField> {
        const response = await this.getCustomFieldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Entity Template returns information about a given entity template.
     * Get Entity Template
     */
    async getEntityTemplateRaw(requestParameters: GetEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityTemplate>> {
        if (requestParameters.entityTemplatePublicId === null || requestParameters.entityTemplatePublicId === undefined) {
            throw new runtime.RequiredError('entityTemplatePublicId','Required parameter requestParameters.entityTemplatePublicId was null or undefined when calling getEntityTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates/{entity-template-public-id}`.replace(`{${"entity-template-public-id"}}`, encodeURIComponent(String(requestParameters.entityTemplatePublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityTemplateFromJSON(jsonValue));
    }

    /**
     * Get Entity Template returns information about a given entity template.
     * Get Entity Template
     */
    async getEntityTemplate(requestParameters: GetEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityTemplate> {
        const response = await this.getEntityTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Epic returns information about the selected Epic.
     * Get Epic
     */
    async getEpicRaw(requestParameters: GetEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Epic>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling getEpic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EpicFromJSON(jsonValue));
    }

    /**
     * Get Epic returns information about the selected Epic.
     * Get Epic
     */
    async getEpic(requestParameters: GetEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Epic> {
        const response = await this.getEpicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns information about the selected Epic Comment.
     * Get Epic Comment
     */
    async getEpicCommentRaw(requestParameters: GetEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadedComment>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling getEpicComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling getEpicComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/comments/{comment-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadedCommentFromJSON(jsonValue));
    }

    /**
     * This endpoint returns information about the selected Epic Comment.
     * Get Epic Comment
     */
    async getEpicComment(requestParameters: GetEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadedComment> {
        const response = await this.getEpicCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Epic Workflow for the Workspace.
     * Get Epic Workflow
     */
    async getEpicWorkflowRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EpicWorkflow>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epic-workflow`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EpicWorkflowFromJSON(jsonValue));
    }

    /**
     * Returns the Epic Workflow for the Workspace.
     * Get Epic Workflow
     */
    async getEpicWorkflow(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EpicWorkflow> {
        const response = await this.getEpicWorkflowRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get Stories which have a given External Link associated with them.
     * Get External Link Stories
     */
    async getExternalLinkStoriesRaw(requestParameters: GetExternalLinkStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.getExternalLinkStoriesParams === null || requestParameters.getExternalLinkStoriesParams === undefined) {
            throw new runtime.RequiredError('getExternalLinkStoriesParams','Required parameter requestParameters.getExternalLinkStoriesParams was null or undefined when calling getExternalLinkStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/external-link/stories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: GetExternalLinkStoriesParamsToJSON(requestParameters.getExternalLinkStoriesParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * Get Stories which have a given External Link associated with them.
     * Get External Link Stories
     */
    async getExternalLinkStories(requestParameters: GetExternalLinkStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.getExternalLinkStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get File returns information about the selected UploadedFile.
     * Get File
     */
    async getFileRaw(requestParameters: GetFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadedFile>> {
        if (requestParameters.filePublicId === null || requestParameters.filePublicId === undefined) {
            throw new runtime.RequiredError('filePublicId','Required parameter requestParameters.filePublicId was null or undefined when calling getFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/files/{file-public-id}`.replace(`{${"file-public-id"}}`, encodeURIComponent(String(requestParameters.filePublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadedFileFromJSON(jsonValue));
    }

    /**
     * Get File returns information about the selected UploadedFile.
     * Get File
     */
    async getFile(requestParameters: GetFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadedFile> {
        const response = await this.getFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Group
     */
    async getGroupRaw(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>> {
        if (requestParameters.groupPublicId === null || requestParameters.groupPublicId === undefined) {
            throw new runtime.RequiredError('groupPublicId','Required parameter requestParameters.groupPublicId was null or undefined when calling getGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups/{group-public-id}`.replace(`{${"group-public-id"}}`, encodeURIComponent(String(requestParameters.groupPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     * Get Group
     */
    async getGroup(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group> {
        const response = await this.getGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Iteration
     */
    async getIterationRaw(requestParameters: GetIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Iteration>> {
        if (requestParameters.iterationPublicId === null || requestParameters.iterationPublicId === undefined) {
            throw new runtime.RequiredError('iterationPublicId','Required parameter requestParameters.iterationPublicId was null or undefined when calling getIteration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations/{iteration-public-id}`.replace(`{${"iteration-public-id"}}`, encodeURIComponent(String(requestParameters.iterationPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IterationFromJSON(jsonValue));
    }

    /**
     * Get Iteration
     */
    async getIteration(requestParameters: GetIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Iteration> {
        const response = await this.getIterationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Label returns information about the selected Label.
     * Get Label
     */
    async getLabelRaw(requestParameters: GetLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.labelPublicId === null || requestParameters.labelPublicId === undefined) {
            throw new runtime.RequiredError('labelPublicId','Required parameter requestParameters.labelPublicId was null or undefined when calling getLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels/{label-public-id}`.replace(`{${"label-public-id"}}`, encodeURIComponent(String(requestParameters.labelPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * Get Label returns information about the selected Label.
     * Get Label
     */
    async getLabel(requestParameters: GetLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Label> {
        const response = await this.getLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get File returns information about the selected Linked File.
     * Get Linked File
     */
    async getLinkedFileRaw(requestParameters: GetLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LinkedFile>> {
        if (requestParameters.linkedFilePublicId === null || requestParameters.linkedFilePublicId === undefined) {
            throw new runtime.RequiredError('linkedFilePublicId','Required parameter requestParameters.linkedFilePublicId was null or undefined when calling getLinkedFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/linked-files/{linked-file-public-id}`.replace(`{${"linked-file-public-id"}}`, encodeURIComponent(String(requestParameters.linkedFilePublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LinkedFileFromJSON(jsonValue));
    }

    /**
     * Get File returns information about the selected Linked File.
     * Get Linked File
     */
    async getLinkedFile(requestParameters: GetLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LinkedFile> {
        const response = await this.getLinkedFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information about a Member.
     * Get Member
     */
    async getMemberRaw(requestParameters: GetMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Member>> {
        if (requestParameters.memberPublicId === null || requestParameters.memberPublicId === undefined) {
            throw new runtime.RequiredError('memberPublicId','Required parameter requestParameters.memberPublicId was null or undefined when calling getMember.');
        }

        if (requestParameters.getMember === null || requestParameters.getMember === undefined) {
            throw new runtime.RequiredError('getMember','Required parameter requestParameters.getMember was null or undefined when calling getMember.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/members/{member-public-id}`.replace(`{${"member-public-id"}}`, encodeURIComponent(String(requestParameters.memberPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: GetMemberToJSON(requestParameters.getMember),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MemberFromJSON(jsonValue));
    }

    /**
     * Returns information about a Member.
     * Get Member
     */
    async getMember(requestParameters: GetMemberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Member> {
        const response = await this.getMemberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Milestone returns information about a chosen Milestone.
     * Get Milestone
     */
    async getMilestoneRaw(requestParameters: GetMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Milestone>> {
        if (requestParameters.milestonePublicId === null || requestParameters.milestonePublicId === undefined) {
            throw new runtime.RequiredError('milestonePublicId','Required parameter requestParameters.milestonePublicId was null or undefined when calling getMilestone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/milestones/{milestone-public-id}`.replace(`{${"milestone-public-id"}}`, encodeURIComponent(String(requestParameters.milestonePublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MilestoneFromJSON(jsonValue));
    }

    /**
     * Get Milestone returns information about a chosen Milestone.
     * Get Milestone
     */
    async getMilestone(requestParameters: GetMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Milestone> {
        const response = await this.getMilestoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Project returns information about the selected Project.
     * Get Project
     */
    async getProjectRaw(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.projectPublicId === null || requestParameters.projectPublicId === undefined) {
            throw new runtime.RequiredError('projectPublicId','Required parameter requestParameters.projectPublicId was null or undefined when calling getProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/projects/{project-public-id}`.replace(`{${"project-public-id"}}`, encodeURIComponent(String(requestParameters.projectPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Get Project returns information about the selected Project.
     * Get Project
     */
    async getProject(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.getProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Repository returns information about the selected Repository.
     * Get Repository
     */
    async getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Repository>> {
        if (requestParameters.repoPublicId === null || requestParameters.repoPublicId === undefined) {
            throw new runtime.RequiredError('repoPublicId','Required parameter requestParameters.repoPublicId was null or undefined when calling getRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/repositories/{repo-public-id}`.replace(`{${"repo-public-id"}}`, encodeURIComponent(String(requestParameters.repoPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepositoryFromJSON(jsonValue));
    }

    /**
     * Get Repository returns information about the selected Repository.
     * Get Repository
     */
    async getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Repository> {
        const response = await this.getRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Story returns information about a chosen Story.
     * Get Story
     */
    async getStoryRaw(requestParameters: GetStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Story>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling getStory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryFromJSON(jsonValue));
    }

    /**
     * Get Story returns information about a chosen Story.
     * Get Story
     */
    async getStory(requestParameters: GetStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Story> {
        const response = await this.getStoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Comment is used to get Comment information.
     * Get Story Comment
     */
    async getStoryCommentRaw(requestParameters: GetStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoryComment>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling getStoryComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling getStoryComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments/{comment-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryCommentFromJSON(jsonValue));
    }

    /**
     * Get Comment is used to get Comment information.
     * Get Story Comment
     */
    async getStoryComment(requestParameters: GetStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoryComment> {
        const response = await this.getStoryCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the stories and their relationship for the given Story Link.
     * Get Story Link
     */
    async getStoryLinkRaw(requestParameters: GetStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoryLink>> {
        if (requestParameters.storyLinkPublicId === null || requestParameters.storyLinkPublicId === undefined) {
            throw new runtime.RequiredError('storyLinkPublicId','Required parameter requestParameters.storyLinkPublicId was null or undefined when calling getStoryLink.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/story-links/{story-link-public-id}`.replace(`{${"story-link-public-id"}}`, encodeURIComponent(String(requestParameters.storyLinkPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryLinkFromJSON(jsonValue));
    }

    /**
     * Returns the stories and their relationship for the given Story Link.
     * Get Story Link
     */
    async getStoryLink(requestParameters: GetStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoryLink> {
        const response = await this.getStoryLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information about a chosen Task.
     * Get Task
     */
    async getTaskRaw(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling getTask.');
        }

        if (requestParameters.taskPublicId === null || requestParameters.taskPublicId === undefined) {
            throw new runtime.RequiredError('taskPublicId','Required parameter requestParameters.taskPublicId was null or undefined when calling getTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/tasks/{task-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"task-public-id"}}`, encodeURIComponent(String(requestParameters.taskPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Returns information about a chosen Task.
     * Get Task
     */
    async getTask(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Task> {
        const response = await this.getTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Workflow returns information about a chosen Workflow.
     * Get Workflow
     */
    async getWorkflowRaw(requestParameters: GetWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Workflow>> {
        if (requestParameters.workflowPublicId === null || requestParameters.workflowPublicId === undefined) {
            throw new runtime.RequiredError('workflowPublicId','Required parameter requestParameters.workflowPublicId was null or undefined when calling getWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/workflows/{workflow-public-id}`.replace(`{${"workflow-public-id"}}`, encodeURIComponent(String(requestParameters.workflowPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowFromJSON(jsonValue));
    }

    /**
     * Get Workflow returns information about a chosen Workflow.
     * Get Workflow
     */
    async getWorkflow(requestParameters: GetWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Workflow> {
        const response = await this.getWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Categories returns a list of all Categories and their attributes.
     * List Categories
     */
    async listCategoriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Category>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryFromJSON));
    }

    /**
     * List Categories returns a list of all Categories and their attributes.
     * List Categories
     */
    async listCategories(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Category>> {
        const response = await this.listCategoriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List Category Milestones returns a list of all Milestones with the Category.
     * List Category Milestones
     */
    async listCategoryMilestonesRaw(requestParameters: ListCategoryMilestonesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Milestone>>> {
        if (requestParameters.categoryPublicId === null || requestParameters.categoryPublicId === undefined) {
            throw new runtime.RequiredError('categoryPublicId','Required parameter requestParameters.categoryPublicId was null or undefined when calling listCategoryMilestones.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/categories/{category-public-id}/milestones`.replace(`{${"category-public-id"}}`, encodeURIComponent(String(requestParameters.categoryPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MilestoneFromJSON));
    }

    /**
     * List Category Milestones returns a list of all Milestones with the Category.
     * List Category Milestones
     */
    async listCategoryMilestones(requestParameters: ListCategoryMilestonesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Milestone>> {
        const response = await this.listCategoryMilestonesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Custom Fields
     */
    async listCustomFieldsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CustomField>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/custom-fields`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomFieldFromJSON));
    }

    /**
     * List Custom Fields
     */
    async listCustomFields(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CustomField>> {
        const response = await this.listCustomFieldsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List all the entity templates for the Workspace.
     * List Entity Templates
     */
    async listEntityTemplatesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EntityTemplate>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EntityTemplateFromJSON));
    }

    /**
     * List all the entity templates for the Workspace.
     * List Entity Templates
     */
    async listEntityTemplates(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EntityTemplate>> {
        const response = await this.listEntityTemplatesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all Comments on an Epic.
     * List Epic Comments
     */
    async listEpicCommentsRaw(requestParameters: ListEpicCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ThreadedComment>>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling listEpicComments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/comments`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ThreadedCommentFromJSON));
    }

    /**
     * Get a list of all Comments on an Epic.
     * List Epic Comments
     */
    async listEpicComments(requestParameters: ListEpicCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ThreadedComment>> {
        const response = await this.listEpicCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all Stories in an Epic.
     * List Epic Stories
     */
    async listEpicStoriesRaw(requestParameters: ListEpicStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling listEpicStories.');
        }

        if (requestParameters.getEpicStories === null || requestParameters.getEpicStories === undefined) {
            throw new runtime.RequiredError('getEpicStories','Required parameter requestParameters.getEpicStories was null or undefined when calling listEpicStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/stories`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: GetEpicStoriesToJSON(requestParameters.getEpicStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * Get a list of all Stories in an Epic.
     * List Epic Stories
     */
    async listEpicStories(requestParameters: ListEpicStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.listEpicStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Epics returns a list of all Epics and their attributes.
     * List Epics
     */
    async listEpicsRaw(requestParameters: ListEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EpicSlim>>> {
        if (requestParameters.listEpics === null || requestParameters.listEpics === undefined) {
            throw new runtime.RequiredError('listEpics','Required parameter requestParameters.listEpics was null or undefined when calling listEpics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: ListEpicsToJSON(requestParameters.listEpics),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EpicSlimFromJSON));
    }

    /**
     * List Epics returns a list of all Epics and their attributes.
     * List Epics
     */
    async listEpics(requestParameters: ListEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EpicSlim>> {
        const response = await this.listEpicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Files returns a list of all UploadedFiles in the workspace.
     * List Files
     */
    async listFilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UploadedFile>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/files`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UploadedFileFromJSON));
    }

    /**
     * List Files returns a list of all UploadedFiles in the workspace.
     * List Files
     */
    async listFiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UploadedFile>> {
        const response = await this.listFilesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List the Stories assigned to the Group. (By default, limited to 1,000).
     * List Group Stories
     */
    async listGroupStoriesRaw(requestParameters: ListGroupStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.groupPublicId === null || requestParameters.groupPublicId === undefined) {
            throw new runtime.RequiredError('groupPublicId','Required parameter requestParameters.groupPublicId was null or undefined when calling listGroupStories.');
        }

        if (requestParameters.listGroupStories === null || requestParameters.listGroupStories === undefined) {
            throw new runtime.RequiredError('listGroupStories','Required parameter requestParameters.listGroupStories was null or undefined when calling listGroupStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups/{group-public-id}/stories`.replace(`{${"group-public-id"}}`, encodeURIComponent(String(requestParameters.groupPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: ListGroupStoriesToJSON(requestParameters.listGroupStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * List the Stories assigned to the Group. (By default, limited to 1,000).
     * List Group Stories
     */
    async listGroupStories(requestParameters: ListGroupStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.listGroupStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A group in our API maps to a \"Team\" within the Shortcut Product. A Team is a collection of Users that can be associated to Stories, Epics, and Iterations within Shortcut.
     * List Groups
     */
    async listGroupsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Group>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupFromJSON));
    }

    /**
     * A group in our API maps to a \"Team\" within the Shortcut Product. A Team is a collection of Users that can be associated to Stories, Epics, and Iterations within Shortcut.
     * List Groups
     */
    async listGroups(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Group>> {
        const response = await this.listGroupsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all Stories in an Iteration.
     * List Iteration Stories
     */
    async listIterationStoriesRaw(requestParameters: ListIterationStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.iterationPublicId === null || requestParameters.iterationPublicId === undefined) {
            throw new runtime.RequiredError('iterationPublicId','Required parameter requestParameters.iterationPublicId was null or undefined when calling listIterationStories.');
        }

        if (requestParameters.getIterationStories === null || requestParameters.getIterationStories === undefined) {
            throw new runtime.RequiredError('getIterationStories','Required parameter requestParameters.getIterationStories was null or undefined when calling listIterationStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations/{iteration-public-id}/stories`.replace(`{${"iteration-public-id"}}`, encodeURIComponent(String(requestParameters.iterationPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: GetIterationStoriesToJSON(requestParameters.getIterationStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * Get a list of all Stories in an Iteration.
     * List Iteration Stories
     */
    async listIterationStories(requestParameters: ListIterationStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.listIterationStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Iterations
     */
    async listIterationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<IterationSlim>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(IterationSlimFromJSON));
    }

    /**
     * List Iterations
     */
    async listIterations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<IterationSlim>> {
        const response = await this.listIterationsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List all of the Epics with the Label.
     * List Label Epics
     */
    async listLabelEpicsRaw(requestParameters: ListLabelEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EpicSlim>>> {
        if (requestParameters.labelPublicId === null || requestParameters.labelPublicId === undefined) {
            throw new runtime.RequiredError('labelPublicId','Required parameter requestParameters.labelPublicId was null or undefined when calling listLabelEpics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels/{label-public-id}/epics`.replace(`{${"label-public-id"}}`, encodeURIComponent(String(requestParameters.labelPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EpicSlimFromJSON));
    }

    /**
     * List all of the Epics with the Label.
     * List Label Epics
     */
    async listLabelEpics(requestParameters: ListLabelEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EpicSlim>> {
        const response = await this.listLabelEpicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all of the Stories with the Label.
     * List Label Stories
     */
    async listLabelStoriesRaw(requestParameters: ListLabelStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.labelPublicId === null || requestParameters.labelPublicId === undefined) {
            throw new runtime.RequiredError('labelPublicId','Required parameter requestParameters.labelPublicId was null or undefined when calling listLabelStories.');
        }

        if (requestParameters.getLabelStories === null || requestParameters.getLabelStories === undefined) {
            throw new runtime.RequiredError('getLabelStories','Required parameter requestParameters.getLabelStories was null or undefined when calling listLabelStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels/{label-public-id}/stories`.replace(`{${"label-public-id"}}`, encodeURIComponent(String(requestParameters.labelPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: GetLabelStoriesToJSON(requestParameters.getLabelStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * List all of the Stories with the Label.
     * List Label Stories
     */
    async listLabelStories(requestParameters: ListLabelStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.listLabelStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Labels returns a list of all Labels and their attributes.
     * List Labels
     */
    async listLabelsRaw(requestParameters: ListLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Label>>> {
        if (requestParameters.listLabels === null || requestParameters.listLabels === undefined) {
            throw new runtime.RequiredError('listLabels','Required parameter requestParameters.listLabels was null or undefined when calling listLabels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: ListLabelsToJSON(requestParameters.listLabels),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LabelFromJSON));
    }

    /**
     * List Labels returns a list of all Labels and their attributes.
     * List Labels
     */
    async listLabels(requestParameters: ListLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Label>> {
        const response = await this.listLabelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Linked Files returns a list of all Linked-Files and their attributes.
     * List Linked Files
     */
    async listLinkedFilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LinkedFile>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/linked-files`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LinkedFileFromJSON));
    }

    /**
     * List Linked Files returns a list of all Linked-Files and their attributes.
     * List Linked Files
     */
    async listLinkedFiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LinkedFile>> {
        const response = await this.listLinkedFilesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns information about members of the Workspace.
     * List Members
     */
    async listMembersRaw(requestParameters: ListMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Member>>> {
        if (requestParameters.listMembers === null || requestParameters.listMembers === undefined) {
            throw new runtime.RequiredError('listMembers','Required parameter requestParameters.listMembers was null or undefined when calling listMembers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: ListMembersToJSON(requestParameters.listMembers),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MemberFromJSON));
    }

    /**
     * Returns information about members of the Workspace.
     * List Members
     */
    async listMembers(requestParameters: ListMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Member>> {
        const response = await this.listMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all of the Epics within the Milestone.
     * List Milestone Epics
     */
    async listMilestoneEpicsRaw(requestParameters: ListMilestoneEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EpicSlim>>> {
        if (requestParameters.milestonePublicId === null || requestParameters.milestonePublicId === undefined) {
            throw new runtime.RequiredError('milestonePublicId','Required parameter requestParameters.milestonePublicId was null or undefined when calling listMilestoneEpics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/milestones/{milestone-public-id}/epics`.replace(`{${"milestone-public-id"}}`, encodeURIComponent(String(requestParameters.milestonePublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EpicSlimFromJSON));
    }

    /**
     * List all of the Epics within the Milestone.
     * List Milestone Epics
     */
    async listMilestoneEpics(requestParameters: ListMilestoneEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EpicSlim>> {
        const response = await this.listMilestoneEpicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Milestones returns a list of all Milestones and their attributes.
     * List Milestones
     */
    async listMilestonesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Milestone>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/milestones`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MilestoneFromJSON));
    }

    /**
     * List Milestones returns a list of all Milestones and their attributes.
     * List Milestones
     */
    async listMilestones(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Milestone>> {
        const response = await this.listMilestonesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List Projects returns a list of all Projects and their attributes.
     * List Projects
     */
    async listProjectsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Project>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProjectFromJSON));
    }

    /**
     * List Projects returns a list of all Projects and their attributes.
     * List Projects
     */
    async listProjects(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Project>> {
        const response = await this.listProjectsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List Repositories returns a list of all Repositories and their attributes.
     * List Repositories
     */
    async listRepositoriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Repository>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/repositories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RepositoryFromJSON));
    }

    /**
     * List Repositories returns a list of all Repositories and their attributes.
     * List Repositories
     */
    async listRepositories(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Repository>> {
        const response = await this.listRepositoriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List Stories returns a list of all Stories in a selected Project and their attributes.
     * List Stories
     */
    async listStoriesRaw(requestParameters: ListStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.projectPublicId === null || requestParameters.projectPublicId === undefined) {
            throw new runtime.RequiredError('projectPublicId','Required parameter requestParameters.projectPublicId was null or undefined when calling listStories.');
        }

        if (requestParameters.getProjectStories === null || requestParameters.getProjectStories === undefined) {
            throw new runtime.RequiredError('getProjectStories','Required parameter requestParameters.getProjectStories was null or undefined when calling listStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/projects/{project-public-id}/stories`.replace(`{${"project-public-id"}}`, encodeURIComponent(String(requestParameters.projectPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: GetProjectStoriesToJSON(requestParameters.getProjectStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * List Stories returns a list of all Stories in a selected Project and their attributes.
     * List Stories
     */
    async listStories(requestParameters: ListStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.listStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists Comments associated with a Story
     * List Story Comment
     */
    async listStoryCommentRaw(requestParameters: ListStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StoryComment>>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling listStoryComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StoryCommentFromJSON));
    }

    /**
     * Lists Comments associated with a Story
     * List Story Comment
     */
    async listStoryComment(requestParameters: ListStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StoryComment>> {
        const response = await this.listStoryCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all Workflows in the Workspace.
     * List Workflows
     */
    async listWorkflowsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Workflow>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/workflows`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkflowFromJSON));
    }

    /**
     * Returns a list of all Workflows in the Workspace.
     * List Workflows
     */
    async listWorkflows(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Workflow>> {
        const response = await this.listWorkflowsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Search lets you search Epics and Stories based on desired parameters. Since ordering of the results can change over time (due to search ranking decay, new Epics and Stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResults>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling search.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: SearchToJSON(requestParameters.search),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultsFromJSON(jsonValue));
    }

    /**
     * Search lets you search Epics and Stories based on desired parameters. Since ordering of the results can change over time (due to search ranking decay, new Epics and Stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search
     */
    async search(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResults> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search Epics lets you search Epics based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new Epics being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Epics
     */
    async searchEpicsRaw(requestParameters: SearchEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EpicSearchResults>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchEpics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/search/epics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: SearchToJSON(requestParameters.search),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EpicSearchResultsFromJSON(jsonValue));
    }

    /**
     * Search Epics lets you search Epics based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new Epics being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Epics
     */
    async searchEpics(requestParameters: SearchEpicsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EpicSearchResults> {
        const response = await this.searchEpicsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search Iterations lets you search Iterations based on desired parameters. Since ordering of results can change over time (due to search ranking decay, new Iterations being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Iterations
     */
    async searchIterationsRaw(requestParameters: SearchIterationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IterationSearchResults>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchIterations.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/search/iterations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: SearchToJSON(requestParameters.search),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IterationSearchResultsFromJSON(jsonValue));
    }

    /**
     * Search Iterations lets you search Iterations based on desired parameters. Since ordering of results can change over time (due to search ranking decay, new Iterations being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Iterations
     */
    async searchIterations(requestParameters: SearchIterationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IterationSearchResults> {
        const response = await this.searchIterationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search Milestones lets you search Milestones based on desired parameters. Since ordering of results can change over time (due to search ranking decay, new Milestones being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Milestones
     */
    async searchMilestonesRaw(requestParameters: SearchMilestonesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MilestoneSearchResults>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchMilestones.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/search/milestones`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: SearchToJSON(requestParameters.search),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MilestoneSearchResultsFromJSON(jsonValue));
    }

    /**
     * Search Milestones lets you search Milestones based on desired parameters. Since ordering of results can change over time (due to search ranking decay, new Milestones being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Milestones
     */
    async searchMilestones(requestParameters: SearchMilestonesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MilestoneSearchResults> {
        const response = await this.searchMilestonesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search Stories lets you search Stories based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Stories
     */
    async searchStoriesRaw(requestParameters: SearchStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorySearchResults>> {
        if (requestParameters.search === null || requestParameters.search === undefined) {
            throw new runtime.RequiredError('search','Required parameter requestParameters.search was null or undefined when calling searchStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/search/stories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: SearchToJSON(requestParameters.search),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorySearchResultsFromJSON(jsonValue));
    }

    /**
     * Search Stories lets you search Stories based on desired parameters. Since ordering of stories can change over time (due to search ranking decay, new stories being created), the `next` value from the previous response can be used as the path and query string for the next page to ensure stable ordering.
     * Search Stories
     */
    async searchStories(requestParameters: SearchStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorySearchResults> {
        const response = await this.searchStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search Stories lets you search Stories based on desired parameters.
     * Search Stories (Old)
     */
    async searchStoriesOldRaw(requestParameters: SearchStoriesOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.searchStories === null || requestParameters.searchStories === undefined) {
            throw new runtime.RequiredError('searchStories','Required parameter requestParameters.searchStories was null or undefined when calling searchStoriesOld.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SearchStoriesToJSON(requestParameters.searchStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * Search Stories lets you search Stories based on desired parameters.
     * Search Stories (Old)
     */
    async searchStoriesOld(requestParameters: SearchStoriesOldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.searchStoriesOldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Story History
     */
    async storyHistoryRaw(requestParameters: StoryHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<History>>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling storyHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/history`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(HistoryFromJSON));
    }

    /**
     * Story History
     */
    async storyHistory(requestParameters: StoryHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<History>> {
        const response = await this.storyHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint allows you to unlink a productboard epic.
     * Unlink Productboard from Epic
     */
    async unlinkProductboardFromEpicRaw(requestParameters: UnlinkProductboardFromEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling unlinkProductboardFromEpic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/unlink-productboard`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint allows you to unlink a productboard epic.
     * Unlink Productboard from Epic
     */
    async unlinkProductboardFromEpic(requestParameters: UnlinkProductboardFromEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unlinkProductboardFromEpicRaw(requestParameters, initOverrides);
    }

    /**
     * Update Category allows you to replace a Category name with another name. If you try to name a Category something that already exists, you will receive a 422 response.
     * Update Category
     */
    async updateCategoryRaw(requestParameters: UpdateCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Category>> {
        if (requestParameters.categoryPublicId === null || requestParameters.categoryPublicId === undefined) {
            throw new runtime.RequiredError('categoryPublicId','Required parameter requestParameters.categoryPublicId was null or undefined when calling updateCategory.');
        }

        if (requestParameters.updateCategory === null || requestParameters.updateCategory === undefined) {
            throw new runtime.RequiredError('updateCategory','Required parameter requestParameters.updateCategory was null or undefined when calling updateCategory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/categories/{category-public-id}`.replace(`{${"category-public-id"}}`, encodeURIComponent(String(requestParameters.categoryPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCategoryToJSON(requestParameters.updateCategory),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryFromJSON(jsonValue));
    }

    /**
     * Update Category allows you to replace a Category name with another name. If you try to name a Category something that already exists, you will receive a 422 response.
     * Update Category
     */
    async updateCategory(requestParameters: UpdateCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Category> {
        const response = await this.updateCategoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Custom Field can be used to update the definition of a Custom Field. The order of items in the \'values\' collection is interpreted to be their ascending sort order.To delete an existing enum value, simply omit it from the \'values\' collection. New enum values may be created inline by including an object in the \'values\' collection having a \'value\' entry with no \'id\' (eg. {\'value\': \'myNewValue\', \'color_key\': \'green\'}).
     * Update Custom Field
     */
    async updateCustomFieldRaw(requestParameters: UpdateCustomFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomField>> {
        if (requestParameters.customFieldPublicId === null || requestParameters.customFieldPublicId === undefined) {
            throw new runtime.RequiredError('customFieldPublicId','Required parameter requestParameters.customFieldPublicId was null or undefined when calling updateCustomField.');
        }

        if (requestParameters.updateCustomField === null || requestParameters.updateCustomField === undefined) {
            throw new runtime.RequiredError('updateCustomField','Required parameter requestParameters.updateCustomField was null or undefined when calling updateCustomField.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/custom-fields/{custom-field-public-id}`.replace(`{${"custom-field-public-id"}}`, encodeURIComponent(String(requestParameters.customFieldPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomFieldToJSON(requestParameters.updateCustomField),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFieldFromJSON(jsonValue));
    }

    /**
     * Update Custom Field can be used to update the definition of a Custom Field. The order of items in the \'values\' collection is interpreted to be their ascending sort order.To delete an existing enum value, simply omit it from the \'values\' collection. New enum values may be created inline by including an object in the \'values\' collection having a \'value\' entry with no \'id\' (eg. {\'value\': \'myNewValue\', \'color_key\': \'green\'}).
     * Update Custom Field
     */
    async updateCustomField(requestParameters: UpdateCustomFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomField> {
        const response = await this.updateCustomFieldRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an entity template\'s name or its contents.
     * Update Entity Template
     */
    async updateEntityTemplateRaw(requestParameters: UpdateEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EntityTemplate>> {
        if (requestParameters.entityTemplatePublicId === null || requestParameters.entityTemplatePublicId === undefined) {
            throw new runtime.RequiredError('entityTemplatePublicId','Required parameter requestParameters.entityTemplatePublicId was null or undefined when calling updateEntityTemplate.');
        }

        if (requestParameters.updateEntityTemplate === null || requestParameters.updateEntityTemplate === undefined) {
            throw new runtime.RequiredError('updateEntityTemplate','Required parameter requestParameters.updateEntityTemplate was null or undefined when calling updateEntityTemplate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/entity-templates/{entity-template-public-id}`.replace(`{${"entity-template-public-id"}}`, encodeURIComponent(String(requestParameters.entityTemplatePublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEntityTemplateToJSON(requestParameters.updateEntityTemplate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EntityTemplateFromJSON(jsonValue));
    }

    /**
     * Update an entity template\'s name or its contents.
     * Update Entity Template
     */
    async updateEntityTemplate(requestParameters: UpdateEntityTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EntityTemplate> {
        const response = await this.updateEntityTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Epic can be used to update numerous fields in the Epic. The only required parameter is Epic ID, which can be found in the Shortcut UI.
     * Update Epic
     */
    async updateEpicRaw(requestParameters: UpdateEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Epic>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling updateEpic.');
        }

        if (requestParameters.updateEpic === null || requestParameters.updateEpic === undefined) {
            throw new runtime.RequiredError('updateEpic','Required parameter requestParameters.updateEpic was null or undefined when calling updateEpic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEpicToJSON(requestParameters.updateEpic),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EpicFromJSON(jsonValue));
    }

    /**
     * Update Epic can be used to update numerous fields in the Epic. The only required parameter is Epic ID, which can be found in the Shortcut UI.
     * Update Epic
     */
    async updateEpic(requestParameters: UpdateEpicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Epic> {
        const response = await this.updateEpicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint allows you to update a threaded Comment on an Epic.
     * Update Epic Comment
     */
    async updateEpicCommentRaw(requestParameters: UpdateEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadedComment>> {
        if (requestParameters.epicPublicId === null || requestParameters.epicPublicId === undefined) {
            throw new runtime.RequiredError('epicPublicId','Required parameter requestParameters.epicPublicId was null or undefined when calling updateEpicComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling updateEpicComment.');
        }

        if (requestParameters.updateComment === null || requestParameters.updateComment === undefined) {
            throw new runtime.RequiredError('updateComment','Required parameter requestParameters.updateComment was null or undefined when calling updateEpicComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/epics/{epic-public-id}/comments/{comment-public-id}`.replace(`{${"epic-public-id"}}`, encodeURIComponent(String(requestParameters.epicPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCommentToJSON(requestParameters.updateComment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadedCommentFromJSON(jsonValue));
    }

    /**
     * This endpoint allows you to update a threaded Comment on an Epic.
     * Update Epic Comment
     */
    async updateEpicComment(requestParameters: UpdateEpicCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadedComment> {
        const response = await this.updateEpicCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update File updates the properties of an UploadedFile (but not its content).
     * Update File
     */
    async updateFileRaw(requestParameters: UpdateFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadedFile>> {
        if (requestParameters.filePublicId === null || requestParameters.filePublicId === undefined) {
            throw new runtime.RequiredError('filePublicId','Required parameter requestParameters.filePublicId was null or undefined when calling updateFile.');
        }

        if (requestParameters.updateFile === null || requestParameters.updateFile === undefined) {
            throw new runtime.RequiredError('updateFile','Required parameter requestParameters.updateFile was null or undefined when calling updateFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/files/{file-public-id}`.replace(`{${"file-public-id"}}`, encodeURIComponent(String(requestParameters.filePublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFileToJSON(requestParameters.updateFile),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadedFileFromJSON(jsonValue));
    }

    /**
     * Update File updates the properties of an UploadedFile (but not its content).
     * Update File
     */
    async updateFile(requestParameters: UpdateFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadedFile> {
        const response = await this.updateFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Group
     */
    async updateGroupRaw(requestParameters: UpdateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>> {
        if (requestParameters.groupPublicId === null || requestParameters.groupPublicId === undefined) {
            throw new runtime.RequiredError('groupPublicId','Required parameter requestParameters.groupPublicId was null or undefined when calling updateGroup.');
        }

        if (requestParameters.updateGroup === null || requestParameters.updateGroup === undefined) {
            throw new runtime.RequiredError('updateGroup','Required parameter requestParameters.updateGroup was null or undefined when calling updateGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/groups/{group-public-id}`.replace(`{${"group-public-id"}}`, encodeURIComponent(String(requestParameters.groupPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateGroupToJSON(requestParameters.updateGroup),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     * Update Group
     */
    async updateGroup(requestParameters: UpdateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group> {
        const response = await this.updateGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Iteration
     */
    async updateIterationRaw(requestParameters: UpdateIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Iteration>> {
        if (requestParameters.iterationPublicId === null || requestParameters.iterationPublicId === undefined) {
            throw new runtime.RequiredError('iterationPublicId','Required parameter requestParameters.iterationPublicId was null or undefined when calling updateIteration.');
        }

        if (requestParameters.updateIteration === null || requestParameters.updateIteration === undefined) {
            throw new runtime.RequiredError('updateIteration','Required parameter requestParameters.updateIteration was null or undefined when calling updateIteration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/iterations/{iteration-public-id}`.replace(`{${"iteration-public-id"}}`, encodeURIComponent(String(requestParameters.iterationPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIterationToJSON(requestParameters.updateIteration),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IterationFromJSON(jsonValue));
    }

    /**
     * Update Iteration
     */
    async updateIteration(requestParameters: UpdateIterationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Iteration> {
        const response = await this.updateIterationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Label allows you to replace a Label name with another name. If you try to name a Label something that already exists, you will receive a 422 response.
     * Update Label
     */
    async updateLabelRaw(requestParameters: UpdateLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Label>> {
        if (requestParameters.labelPublicId === null || requestParameters.labelPublicId === undefined) {
            throw new runtime.RequiredError('labelPublicId','Required parameter requestParameters.labelPublicId was null or undefined when calling updateLabel.');
        }

        if (requestParameters.updateLabel === null || requestParameters.updateLabel === undefined) {
            throw new runtime.RequiredError('updateLabel','Required parameter requestParameters.updateLabel was null or undefined when calling updateLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/labels/{label-public-id}`.replace(`{${"label-public-id"}}`, encodeURIComponent(String(requestParameters.labelPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateLabelToJSON(requestParameters.updateLabel),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LabelFromJSON(jsonValue));
    }

    /**
     * Update Label allows you to replace a Label name with another name. If you try to name a Label something that already exists, you will receive a 422 response.
     * Update Label
     */
    async updateLabel(requestParameters: UpdateLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Label> {
        const response = await this.updateLabelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updated Linked File allows you to update properties of a previously attached Linked-File.
     * Update Linked File
     */
    async updateLinkedFileRaw(requestParameters: UpdateLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LinkedFile>> {
        if (requestParameters.linkedFilePublicId === null || requestParameters.linkedFilePublicId === undefined) {
            throw new runtime.RequiredError('linkedFilePublicId','Required parameter requestParameters.linkedFilePublicId was null or undefined when calling updateLinkedFile.');
        }

        if (requestParameters.updateLinkedFile === null || requestParameters.updateLinkedFile === undefined) {
            throw new runtime.RequiredError('updateLinkedFile','Required parameter requestParameters.updateLinkedFile was null or undefined when calling updateLinkedFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/linked-files/{linked-file-public-id}`.replace(`{${"linked-file-public-id"}}`, encodeURIComponent(String(requestParameters.linkedFilePublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateLinkedFileToJSON(requestParameters.updateLinkedFile),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LinkedFileFromJSON(jsonValue));
    }

    /**
     * Updated Linked File allows you to update properties of a previously attached Linked-File.
     * Update Linked File
     */
    async updateLinkedFile(requestParameters: UpdateLinkedFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LinkedFile> {
        const response = await this.updateLinkedFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Milestone can be used to update Milestone properties.
     * Update Milestone
     */
    async updateMilestoneRaw(requestParameters: UpdateMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Milestone>> {
        if (requestParameters.milestonePublicId === null || requestParameters.milestonePublicId === undefined) {
            throw new runtime.RequiredError('milestonePublicId','Required parameter requestParameters.milestonePublicId was null or undefined when calling updateMilestone.');
        }

        if (requestParameters.updateMilestone === null || requestParameters.updateMilestone === undefined) {
            throw new runtime.RequiredError('updateMilestone','Required parameter requestParameters.updateMilestone was null or undefined when calling updateMilestone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/milestones/{milestone-public-id}`.replace(`{${"milestone-public-id"}}`, encodeURIComponent(String(requestParameters.milestonePublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMilestoneToJSON(requestParameters.updateMilestone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MilestoneFromJSON(jsonValue));
    }

    /**
     * Update Milestone can be used to update Milestone properties.
     * Update Milestone
     */
    async updateMilestone(requestParameters: UpdateMilestoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Milestone> {
        const response = await this.updateMilestoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Multiple Stories allows you to make changes to numerous stories at once.
     * Update Multiple Stories
     */
    async updateMultipleStoriesRaw(requestParameters: UpdateMultipleStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StorySlim>>> {
        if (requestParameters.updateStories === null || requestParameters.updateStories === undefined) {
            throw new runtime.RequiredError('updateStories','Required parameter requestParameters.updateStories was null or undefined when calling updateMultipleStories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/bulk`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateStoriesToJSON(requestParameters.updateStories),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorySlimFromJSON));
    }

    /**
     * Update Multiple Stories allows you to make changes to numerous stories at once.
     * Update Multiple Stories
     */
    async updateMultipleStories(requestParameters: UpdateMultipleStoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StorySlim>> {
        const response = await this.updateMultipleStoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Project can be used to change properties of a Project.
     * Update Project
     */
    async updateProjectRaw(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.projectPublicId === null || requestParameters.projectPublicId === undefined) {
            throw new runtime.RequiredError('projectPublicId','Required parameter requestParameters.projectPublicId was null or undefined when calling updateProject.');
        }

        if (requestParameters.updateProject === null || requestParameters.updateProject === undefined) {
            throw new runtime.RequiredError('updateProject','Required parameter requestParameters.updateProject was null or undefined when calling updateProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/projects/{project-public-id}`.replace(`{${"project-public-id"}}`, encodeURIComponent(String(requestParameters.projectPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateProjectToJSON(requestParameters.updateProject),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Update Project can be used to change properties of a Project.
     * Update Project
     */
    async updateProject(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Project> {
        const response = await this.updateProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Story can be used to update Story properties.
     * Update Story
     */
    async updateStoryRaw(requestParameters: UpdateStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Story>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling updateStory.');
        }

        if (requestParameters.updateStory === null || requestParameters.updateStory === undefined) {
            throw new runtime.RequiredError('updateStory','Required parameter requestParameters.updateStory was null or undefined when calling updateStory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateStoryToJSON(requestParameters.updateStory),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryFromJSON(jsonValue));
    }

    /**
     * Update Story can be used to update Story properties.
     * Update Story
     */
    async updateStory(requestParameters: UpdateStoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Story> {
        const response = await this.updateStoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Comment replaces the text of the existing Comment.
     * Update Story Comment
     */
    async updateStoryCommentRaw(requestParameters: UpdateStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoryComment>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling updateStoryComment.');
        }

        if (requestParameters.commentPublicId === null || requestParameters.commentPublicId === undefined) {
            throw new runtime.RequiredError('commentPublicId','Required parameter requestParameters.commentPublicId was null or undefined when calling updateStoryComment.');
        }

        if (requestParameters.updateStoryComment === null || requestParameters.updateStoryComment === undefined) {
            throw new runtime.RequiredError('updateStoryComment','Required parameter requestParameters.updateStoryComment was null or undefined when calling updateStoryComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/comments/{comment-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"comment-public-id"}}`, encodeURIComponent(String(requestParameters.commentPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateStoryCommentToJSON(requestParameters.updateStoryComment),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryCommentFromJSON(jsonValue));
    }

    /**
     * Update Comment replaces the text of the existing Comment.
     * Update Story Comment
     */
    async updateStoryComment(requestParameters: UpdateStoryCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoryComment> {
        const response = await this.updateStoryCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the stories and/or the relationship for the given Story Link.
     * Update Story Link
     */
    async updateStoryLinkRaw(requestParameters: UpdateStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoryLink>> {
        if (requestParameters.storyLinkPublicId === null || requestParameters.storyLinkPublicId === undefined) {
            throw new runtime.RequiredError('storyLinkPublicId','Required parameter requestParameters.storyLinkPublicId was null or undefined when calling updateStoryLink.');
        }

        if (requestParameters.updateStoryLink === null || requestParameters.updateStoryLink === undefined) {
            throw new runtime.RequiredError('updateStoryLink','Required parameter requestParameters.updateStoryLink was null or undefined when calling updateStoryLink.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/story-links/{story-link-public-id}`.replace(`{${"story-link-public-id"}}`, encodeURIComponent(String(requestParameters.storyLinkPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateStoryLinkToJSON(requestParameters.updateStoryLink),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoryLinkFromJSON(jsonValue));
    }

    /**
     * Updates the stories and/or the relationship for the given Story Link.
     * Update Story Link
     */
    async updateStoryLink(requestParameters: UpdateStoryLinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoryLink> {
        const response = await this.updateStoryLinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Task can be used to update Task properties.
     * Update Task
     */
    async updateTaskRaw(requestParameters: UpdateTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Task>> {
        if (requestParameters.storyPublicId === null || requestParameters.storyPublicId === undefined) {
            throw new runtime.RequiredError('storyPublicId','Required parameter requestParameters.storyPublicId was null or undefined when calling updateTask.');
        }

        if (requestParameters.taskPublicId === null || requestParameters.taskPublicId === undefined) {
            throw new runtime.RequiredError('taskPublicId','Required parameter requestParameters.taskPublicId was null or undefined when calling updateTask.');
        }

        if (requestParameters.updateTask === null || requestParameters.updateTask === undefined) {
            throw new runtime.RequiredError('updateTask','Required parameter requestParameters.updateTask was null or undefined when calling updateTask.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const response = await this.request({
            path: `/api/v3/stories/{story-public-id}/tasks/{task-public-id}`.replace(`{${"story-public-id"}}`, encodeURIComponent(String(requestParameters.storyPublicId))).replace(`{${"task-public-id"}}`, encodeURIComponent(String(requestParameters.taskPublicId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTaskToJSON(requestParameters.updateTask),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFromJSON(jsonValue));
    }

    /**
     * Update Task can be used to update Task properties.
     * Update Task
     */
    async updateTask(requestParameters: UpdateTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Task> {
        const response = await this.updateTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload Files uploads one or many files and optionally associates them with a story.    Use the multipart/form-data content-type to upload.    Each `file` key should contain a separate file.    Each UploadedFile\'s name comes from the Content-Disposition header \"filename\" directive for that field.
     * Upload Files
     */
    async uploadFilesRaw(requestParameters: UploadFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UploadedFile>>> {
        if (requestParameters.file0 === null || requestParameters.file0 === undefined) {
            throw new runtime.RequiredError('file0','Required parameter requestParameters.file0 was null or undefined when calling uploadFiles.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Shortcut-Token"] = this.configuration.apiKey("Shortcut-Token"); // api_token authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.storyId !== undefined) {
            formParams.append('story_id', requestParameters.storyId as any);
        }

        if (requestParameters.file0 !== undefined) {
            formParams.append('file0', requestParameters.file0 as any);
        }

        if (requestParameters.file1 !== undefined) {
            formParams.append('file1', requestParameters.file1 as any);
        }

        if (requestParameters.file2 !== undefined) {
            formParams.append('file2', requestParameters.file2 as any);
        }

        if (requestParameters.file3 !== undefined) {
            formParams.append('file3', requestParameters.file3 as any);
        }

        const response = await this.request({
            path: `/api/v3/files`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UploadedFileFromJSON));
    }

    /**
     * Upload Files uploads one or many files and optionally associates them with a story.    Use the multipart/form-data content-type to upload.    Each `file` key should contain a separate file.    Each UploadedFile\'s name comes from the Content-Disposition header \"filename\" directive for that field.
     * Upload Files
     */
    async uploadFiles(requestParameters: UploadFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UploadedFile>> {
        const response = await this.uploadFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
